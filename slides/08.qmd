---
engine: knitr
title: Conditions
---

## Learning objectives

- What conditions are
- How to generate ("signal") them
- How to consume ("handle") them

## R's condition system allows us to handle things going wrong

This helps us treat each function as a "black box."

An error might occur due to events outside of your program---a missing file, a
full disk, a crashed server, etc.

"Errors aren't caused by bugs, but neglecting to handle an error is almost
certainly a bug." ---Seibel (2003)

## There are three types of conditions

1. `r emoji::emoji("x")` Errors
2. `r emoji::emoji("warning")` Warnings
3. `r emoji::emoji("speech_balloon")` Messages

Function authors _signal_ conditions

Function users _handle_ conditions

# Signaling conditions

## Errors indicate that a problem occurred and the function cannot continue

```{r}
#| error: true
f <- function() {
  g()
  cat("finishing f()\n")
}

g <- function() {
  h()
  cat("finishing g()\n")
}

h <- function() {
  stop("This is an error!")
  cat("finishing h()\n")
}

f()
```

::: {.notes}
Errors halt execution immediately
:::

## Pass objects to `stop()` to print error messages

- `stop(...)` can accept zero or more objects
  - If the first object is not a condition object[^objs], its arguments are
    converted to character and pasted together with no separator

- Pass `call. = FALSE` to prevent the call from being added to the error message

- `rlang::abort()` signals errors with a different interface

[^objs]: _Condition objects_ will be described later

## Tracebacks display the call stack at the time of the last error

```{r}
#| eval: false
f()
traceback()
```

    #> 4: stop("This is an error!") at #2
    #> 3: h() at #2
    #> 2: g() at #2
    #> 1: f()

This is one reason to prefer `stop(..., call. = FALSE)`

## `rlang::last_trace()` has prettier printing

```{r}
#| eval: false
f()
rlang::last_trace()
```

    #> <error/rlang_error>
    #> Error in `h()`:
    #> ! This is an error!
    #> ---
    #> Backtrace:
    #>     ▆
    #>  1. └─global f()
    #>  2.   └─global g()
    #>  3.     └─global h()
    #> Run rlang::last_trace(drop = FALSE) to see 1 hidden frame.

## Warnings indicate that a problem occurred but the function can continue

<!---
I'm using eval = false and embedding the output myself because Quarto displays
warnings immediately unlike the R console (with `options(warn = 0)`)
-->

```{r}
#| eval: false
f <- function() {
  warning("F1")
  g()
  warning("F2")
  cat("finishing f()\n")
}

g <- function() {
  warning("G1")
  cat("finishing g()\n")
}

f()
```

    #> finishing g()
    #> finishing f()
    #> Warning messages:
    #> 1: In f() : F1
    #> 2: In g() : G1
    #> 3: In f() : F2

::: {.notes}
By default warnings are cached and printed when control returns to the top
level, as shown here (use `options(warn = 0)`)

Warnings can appear immediately with `options(warn = 1)`

Warnings can turn into errors with `options(warn = 2)`, which is ideal for
debugging
:::

## Use warnings sparingly

- Ideal for deprecating functions
- Good when "you are reasonably certain" that a problem is recoverable
- "Base R tends to overuse warnings, and many warnings in base R would be
  better off as errors"

::: aside
`warning()` has similar arguments to `stop()`, `call. = TRUE` is generally more
useful here

`rlang::warn()` is an alternative (cf. `rlang::abort()`)
:::

## Messages indicate that something noteworthy has happened

```{r}
#| message: true
f <- function() {
  message("F1")
  g()
  message("F2")
  cat("finishing f()\n")
}

g <- function() {
  message("G1")
  cat("finishing g()\n")
}

f()
```

## Good uses for messages

- Explaining default arguments
- Status updates of for functions used primarily for side-effects (e.g.,
  interaction with web API, file downloaded, etc.)
- Progress of long-running process (in the absence of a status bar)
- Package loading message (e.g., attaching package, objects masked)

::: aside
See `rlang::inform()` for an alternative interface
:::

# Handling conditions

## Ignore errors with `try()`

::: {.notes}
- Displays error
- But continues execution after error
:::

```{r}
#| error: true
bad_log <- function(x) {
  try(log(x))
  10
}

bad_log("bad")
```

## Use `try()` with assignment to define default values in case of failure

```{r}
file_contents <- NULL
try(file_contents <- read.csv("possibly-bad-input.csv"), silent = TRUE)
is.null(file_contents)
```

## Warnings and messages can be independently suppressed

<!---
I'm turning off evaluation and manually pasting the results again because I
want to make the formatting match
-->

```{r}
#| eval: false
chatty_function <- function() {
  warning("warning 1")
  message("message 1")
  warning("warning 2")
  message("message 2")
  42
}

suppressWarnings(chatty_function())
```

    #> message 1
    #> message 2
    #> [1] 42

```{r}
#| eval: false
suppressMessages(chatty_function())
```

    #> [1] 42
    #> Warning messages:
    #> 1: In chatty_function() : warning 1
    #> 2: In chatty_function() : warning 2

## Every condition has a default behavior:

- `r emoji::emoji("x")` Errors halt execution
- `r emoji::emoji("warning")` Warnings are collected during execution and
  displayed in bulk after execution
- `r emoji::emoji("speech_balloon")` Messages are displayed immediately

These default behaviros can be changed through exiting and calling handlers

## Use `tryCatch()` to specify exiting handlers or change their behavior

```{r}
#| error: true
exp_log <- function(x) {
  tryCatch(
    error = function(cnd) {
      NA
    },
    {
      y <- log(x)
      cat("Reconstituting 'x'\n")
      exp(y)
    }
  )
}

exp_log(23)
```

```{r}
#| error: true
exp_log("x")
```

## Exiting handlers never return control to the original code

```{r}
tryCatch(
  message = function(cnd) {
    cat("Caught a message condition:", conditionMessage(cnd))
    "The return value of the message handler"
  },
  {
    message("This is a message")
    cat("This code won't be run inside 'tryCatch()' if messages are caught\n")
    "The return value of the original expression"
  },
  finally = {
    cat("This code is always run\n")
  }
)
```

## Use `withCallingHandlers()` to change default calling handler behavior

```{r}
withCallingHandlers(
  message = function(cnd) {
    cat("Caught a message condition:", conditionMessage(cnd))
    "The return value of the message handler is ignored"
  },
  {
    message("This is a message")
    cat("This code should run\n")
    message("This is another message")
    "The return value of the original expression"
  }
  # No finally option
)
```

## Conditions propagate by default

```{r}
# Bubbles all the way up to default handler which generates the message
withCallingHandlers(
  message = function(cnd) cat("Level 2\n"),
  withCallingHandlers(
    message = function(cnd) cat("Level 1\n"),
    {
      message("Hello")
      cat("Finishing code block\n")
    }
  )
)
```

## Conditions also bubble up to `tryCatch()`

```{r}
tryCatch(
  message = function(cnd) cat("Level 2\n"),
  withCallingHandlers(
    message = function(cnd) cat("Level 1\n"),
    {
      message("Hello")
      cat("This exiting handler prevents this from running\n")
    }
  )
)
```

## Use `rlang::cnd_muffle()` to stop the propagation

```{r}
# Muffles level 2 handler and the default handler
withCallingHandlers(
  message = function(cnd) cat("Level 2\n"),
  withCallingHandlers(
    message = function(cnd) {
      cat("Level 1\n")
      rlang::cnd_muffle(cnd)
    },
    message("Hello")
  )
)
```

## Calling handlers are called in the context of the call that signaled the conditon

```{r}
# create a function
f <- function() g()
g <- function() message("hello")

# call stack of calling handlers
withCallingHandlers(f(), message = function(cnd) {
  lobstr::cst()
  rlang::cnd_muffle(cnd)
})
```

## Exiting handlers are called in the context of the call to `tryCatch()`

```{r}
tryCatch(f(), message = function(cnd) lobstr::cst())
```

# Condition objects

## Built-in conditions are lists with two elements

```{r}
cnd <- rlang::catch_cnd(stop("An error!"))
str(cnd)
```

- The `call` feels like one of those things that might be useful when we learn
  metaprogramming (maybe)

- The `message` is straightforward, and can be accessed with
  `conditionMessage(cnd)`

## Custom conditions can have other attributes

```{r}
cnd <- rlang::catch_cnd(rlang::abort("An error!"))
str(cnd)
```

## Use `rlang::abort()` to compose and throw a custom condition

```{r}
#| error: true
abort_missing_file <- function(file_path) {
  rlang::abort(
    "error_not_found",
    message = glue::glue("Path `{file_path}` not found"),
    path = file_path
  )
}
abort_missing_file("blah.csv")
```

## Custom conditions can be dealt with by new handlers

```{r}
my_csv_reader <- function(file) {
  if (!file.exists(file)) abort_missing_file(file)
  read.csv(file)
}

dat <- tryCatch(
  error_not_found = function(cnd) data.frame(),
  error = function(cnd) NULL,
  my_csv_reader("blah.csv")
)

dat
```

::: {.notes}
Of course we could put this behavior in `my_csv_reader()` if we were writing
the function and the handler.

The strength of custom conditions is that it would let's the function author
defer a decision about what to do about (e.g.) a missing file to the function
user in a flexible way.
:::

## Applications

See [the sub-section in the
book](https://adv-r.hadley.nz/conditions.html#condition-applications) for
excellent examples.

## Resources

- Conditions articles in rlang vignettes: 
  - [Including function calls in error
    messages](https://rlang.r-lib.org/reference/topic-error-call.html)
  - [Including contextual information with error
    chains](https://rlang.r-lib.org/reference/topic-error-chaining.html)
  - [Formatting messages with
    cli](https://rlang.r-lib.org/reference/topic-condition-formatting.html)
- [Other
  resources](https://github.com/rstudio-conf-2022/pkg-dev-masterclass/blob/main/materials/5-error-resources.md)
from error message segment of rstudio::conf(2022) workshop "Package Development
Masterclass"
